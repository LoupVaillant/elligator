{
    title: The Elligator map and reverse map
    description: Describes how to apply Elligator mathematically
}

The Elligator map and reverse map
=================================

Elligator specifies two kinds of maps,
the &ldquo;map&rdquo; (or &ldquo;direct map&rdquo; for clarity)
and the &ldquo;inverse map&rdquo;.

The map is a function that takes a number <var>r</var> from a an
elliptic curve's finite field (which we call a _field element_),
and produces a point
<var>P</var>&nbsp;=&nbsp;(<var>u</var>,&nbsp;<var>v</var>)
on that elliptic curve.
Note that the map is not quite injective:
<var>r</var> and &minus;<var>r</var> map to the same point.
Numbers that are neither equal nor opposite do map to different points
though.

The _inverse_ map is a function that takes as input an elliptic curve
point <var>P</var> and outputs a field element <var>r</var>.
We also call that number the &ldquo;representative&rdquo; because it
represents a point on the curve.
Note that _only about half_ of the curve can be mapped back.

For any given point <var>P</var> that can be mapped,
applying the inverse map then the direct map will yield the original
point <var>P</var>.

For any representative <var>r</var> in the curve's finite field,
applying the direct map then the inverse map will yield either the
original representative <var>r</var> or its opposite
&minus;<var>r</var>.


Applicability
-------------

Elligator does not work on all elliptic curves,
and will not properly hide points on all curves where it does work.
Some conditions must hold:

- The finite field the curve is based on must have an odd
  characteristic.
  That is, not a binary field.
  In practice, most curves use large prime fields, which are all odd.
  While extension fields and binary fields can sometimes be faster,
  prime fields have a more compelling security story.

- The curve is expressible in the form
  <var>v</var><sup>2</sup>&nbsp;=&nbsp;<var>u</var><sup>3</sup>&nbsp;+&nbsp;<var>A</var><var>u</var><sup>2</sup>&nbsp;+&nbsp;<var>B</var><var>u</var>,
  such that
  <var>A</var><var>B</var>(<var>A</var><sup>2</sup>&nbsp;&minus;&nbsp;4<var>B</var>)&nbsp;&ne;&nbsp;0.
  Note that this includes all Montgomery curves of the form
  <var>v</var><sup>2</sup>&nbsp;=&nbsp;<var>u</var><sup>3</sup>&nbsp;+&nbsp;<var>A</var><var>u</var><sup>2</sup>&nbsp;+&nbsp;<var>u</var>
  (except
  <var>v</var><sup>2</sup>&nbsp;=&nbsp;<var>u</var><sup>3</sup>&nbsp;+&nbsp;<var>u</var>),
  including Curve25519 and Curve448.
  In practice, almost any curve with an odd field and a point of
  order&nbsp;two can be written in this form.

- Additionally,
  for Elligator to properly hide points on the curve as random noise,
  The characteristic of its field must be very close to a power of two.
  This is because we're ultimately transmitting bit strings over the
  network,
  whose range is always a power of two.
  In practice, only Mersenne primes (2<sup>k</sup>&nbsp;&minus;&nbsp;1),
  pseudo-Mersenne primes (2<sup>k</sup>&nbsp;&minus;&nbsp;<var>c</var>),
  and _some_ Solinas primes
  (2<sup>k</sup>&nbsp;&minus;&nbsp;2<sup>l</sup>&nbsp;&hellip;&nbsp;&minus;&nbsp;1
  where <var>k</var>&nbsp;&minus;&nbsp;<var>l</var> ideally exceeds 128)
  are adequate.

Overall, those conditions cover a wide range of curves,
including the very popular Curve25519 and Curve448.
One notable exception are short Weierstraß curves like NIST P-256,
which have a prime order,
and therefore lack a point of order two.

<aside>
Those already familiar with Elligator may realize that we're actually
talking about Elligator&nbsp;2.
That's because Elligator&nbsp;1 is less widely applicable,
has no other compelling benefits,
and as a result has not caugth on.
It is thus simpler to ignore it.
</aside>


Instantiation Parameters
------------------------

An Elligator instantiation works over a specific curve,
and has a couple parameters of its own.
Before actually defining the maps, we need to fix those parameters.

- The **finite field** GF(<var>q</var>) over which the curve operates.
  Note that <var>q</var> is always the power of a prime.
  That is, <var>q</var>&nbsp;=&nbsp;<var>p</var><sup><var>m</var></sup>,
  for some prime <var>p</var> and some strictly positive integer
  <var>m</var>.
  Most of the time though,
  we'll be using a prime field,
  where <var>q</var>&nbsp;=&nbsp;<var>p</var>.

  Examples of finite fields include
  GF(2<sup>255</sup>&nbsp;&minus;&nbsp;19),
  used by Curve25519,
  and
  GF(2<sup>448</sup>&nbsp;&minus;&nbsp;2<sup>224</sup>&nbsp;&minus;&nbsp;19),
  used by Curve448.

- The **elliptic curve**, defined by the equation
  <var>v</var><sup>2</sup>&nbsp;=&nbsp;<var>u</var><sup>3</sup>&nbsp;+&nbsp;<var>A</var><var>u</var><sup>2</sup>&nbsp;+&nbsp;<var>B</var><var>u</var>.

  Examples of elliptic curves include Curve25519
  (<var>A</var>&nbsp;=&nbsp;486662, <var>B</var>&nbsp;=&nbsp;1) and
  Curve448 (<var>A</var>&nbsp;=&nbsp;156326, <var>B</var>&nbsp;=&nbsp;1).

- The **non-square** <var>Z</var> in GF(<var>q</var>).
  It can be any number in GF(<var>p</var>) that has no square root.
  That is, there is no number <var>n</var> in GF(<var>q</var>) such that
  <var>n</var><sup>2</sup>&nbsp;=&nbsp;<var>Z</var>.

  We generally chose <var>Z</var> to minisise computations down the
  line, like small numbers,
  or numbers tailored to speed up specific implementations.
  With GF(2<sup>255</sup>&nbsp;&minus;&nbsp;19),
  those would be 2 and &radic;&minus;1 respectively.

- The **set of principal square roots** &ndash;
  or the set of positive field elements.
  A square <var>s</var> in GF(<var>q</var>) always has two square roots:
  &radic;<var>s</var> and &minus;&radic;<var>s</var>.
  We need a way to determine which is which for the direct and inverse
  map to be deterministic.

  For prime fields GF(<var>p</var>) where
  <var>p</var>&nbsp;&equiv;&nbsp;3&nbsp;(mod&nbsp;4), we can just chose
  <var>s</var><sup>(<var>p</var>+1)/4</sup>.
  For other prime fields,
  where <var>p</var>&nbsp;&equiv;&nbsp;1&nbsp;(mod&nbsp;4),
  we generally fall back to the set
  {0,&nbsp;1,&nbsp;…&nbsp;(<var>p</var>&minus;1)/2},
  or (as is done in the Ed25519 signature scheme) the set of even
  numbers.

<aside>
For the implementation of square roots and checking whether a number is
a square root in GF(<var>p</var>),
refer to [I-D.draft-irtf-cfrg-hash-to-curve-11, appendix&nbsp;I](https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-11#appendix-I).
</aside>


The direct map
--------------

First, we need to define the `legendre()` function;
it computes the [Legendre symbol](https://en.wikipedia.org/wiki/Legendre_symbol),
of a field element f:

- `legendre`(<var>f</var>)&nbsp;=&nbsp;0 if <var>f</var> is zero.
- `legendre`(<var>f</var>)&nbsp;=&nbsp;1 if <var>f</var> is a square.
- `legendre`(<var>f</var>)&nbsp;=&nbsp;&minus;1 if <var>f</var> is not a
  square.

This can be constructed using the square root checking functions needed
to find the chosen non-square <var>Z</var> above.
In prime fields, it can also succinctly be defined as:
`legendre`(<var>f</var>)&nbsp;=&nbsp;<var>f</var><sup>(<var>p</var>&nbsp;&minus;&nbsp;1)&nbsp;/&nbsp;2</sup>.

The map itself takes any field element <var>r</var> (the
representative),
and outputs a point
<var>P</var>&nbsp;=&nbsp;(<var>u</var>,&nbsp;<var>v</var>) on the curve
as follows:

- <var>w</var>&nbsp;=&nbsp;&minus;<var>A</var>&nbsp;/&nbsp;(1&nbsp;+&nbsp;<var>Z</var>&nbsp;<var>r</var><sup>2</sup>)
- <var>e</var>&nbsp;=&nbsp;`legendre`(<var>w</var><sup>3</sup>&nbsp;+&nbsp;<var>A</var>&nbsp;<var>w</var><sup>2</sup>&nbsp;+&nbsp;<var>B</var>&nbsp;<var>w</var>)
- <var>u</var>&nbsp;=&nbsp;<var>e</var>&nbsp;<var>w</var>&nbsp;&minus;&nbsp;(1&nbsp;&minus;&nbsp;<var>e</var>)&nbsp;(<var>A</var>&nbsp;/&nbsp;2)
- <var>v</var>&nbsp;=&nbsp;&minus;<var>e</var>&nbsp;&radic;(<var>u</var><sup>3</sup>&nbsp;+&nbsp;A&nbsp;u<sup>2</sup>&nbsp;+&nbsp;<var>B</var>&nbsp;<var>u</var>)
- <var>P</var>&nbsp;=&nbsp;(<var>u</var>,&nbsp;<var>v</varsity>)


The inverse map
---------------

Unlike the direct map,
the inverse map does _not_ work for all points on the curve.
It only holds for points
<var>P</var>&nbsp;=&nbsp;(<var>u</var>,&nbsp;<var>v</var>) such that:

- <var>u</var>&nbsp;&ne;&nbsp;&minus;A;
- &minus;<var>Z</var><var>u</var>(<var>u</var>&nbsp;+&nbsp;<var>A</var>)
  is a square;
- If <var>v</var>&nbsp;=&nbsp;0,
  then <var>u</var>&nbsp;=&nbsp;0 as well.

Assuming those conditions hold, the representative <var>r</var> of
<var>P</var>&nbsp;=&nbsp;(<var>u</var>,&nbsp;<var>v</var>) is computed
as follows:

- If <var>v</var> is a principal square root,
  <var>r</var>&nbsp;=&nbsp;&radic;(&minus;<var>u</var>&nbsp;/&nbsp;(<var>Z</var>&nbsp;(<var>u</var>&nbsp;+&nbsp;<var>A</var>)))
- If <var>v</var> is _not_ a principal square root,
  <var>r</var>&nbsp;=&nbsp;&radic;(&minus;(<var>u</var>&nbsp;+&nbsp;<var>A</var>)&nbsp;/&nbsp;(<var>Z</var>&nbsp;<var>u</var>))


### Properly serialising representatives

You may have noticed that the reverse map only generates principal
square roots.
That is, half of all possible representatives.
If we sent that directly over the network,
it would be easy for an eavesdropper to notice that one bit is
effectively always zero,
and suspect our use of Elligator.
There are two ways to mitigate this problem:

- We can flip the sign of <var>r</var> at random.
  That is, half the time, we chose &minus;<var>r</var> instead of
  <var>r</var>
  (use constant time selection to do this).
  This will not affect the direct map when we try to recover the point
  <var>P</var>,
  because `map`(<var>r</var>)&nbsp;=&nbsp;`map`(&minus;<var>r</var>).
- If the bit-string representation of a principal square root
  systematically leaves one of its bits cleared,
  then we can replace it by a random bit instead.
  Of course,
  we must ignore that random bit when we parse the bit-string back.

Furthermore,
we generally send _byte_-strings over the network.
If the length of the bit-string is not a multiple of&nbsp;8,
the remaining bits must be filled with random data for the whole byte
string to look random.
Of course,
we must ignore those random bits when we parse the bit-string.


Using Elligator to hide key exchanges
-------------------------------------

One does not simply map a point to its representative.
There are three caveats to keep in mind.

First,
this is only effective on _ephemeral_ keys.
Using Elligator to hide static public keys will not work,
because if you send the same representative over and over,
it won't look random at all.

Second,
not all public keys are eligible for the inverse map.
We need to keep generating random ephemeral key pairs until we find a
public key that can be mapped.
This requires two tries on average.

<aside>
While the &ldquo;check and retry&rdquo; approach is not constant time,
assuming the keys were properly selected at random,
leaking the number of tries to an eavesdropper will not reveal anything
else.
</aside>

Third, actual key exchange algorithms do not work over the whole curve.
To avoid leaking information,
they only work on the _prime order subgroup_.
The public keys used for those always belong to that subgroup,
which comprises only a fraction of the curve.
If we only used those,
an eavesdropper could easily notice that all representatives happen to
map to points in the prime order subgroup.

That third point is the most problematic,
and in the past has caused professional cryptographers to fail to
deliver what Elligator promises.
We need a way to generate points on the _whole_ curve,
and somehow make key exchange work regardless.

One obvious way to make it work is to _not_ [clear the
cofactor](https://loup-vaillant.fr/tutorials/cofactor).
This means chosing a base point that generates the whole curve instead
of the prime order subgroup,
and choosing a uniformly random scalar between zero and the order of the
whole curve
(the _whole_ curve,
not just the prime order subgroup).

It is more practical however to find a way to be compatible with
existing key exchange algorithms.
This lets us retain many of the proofs and guarantees of the original
key exchange,
and significantly streamlines the APIs.
The details depend on the particular key exchange we want to be
compatible with.
Here we will give an example based on X25519 and X448.


### X25519 and X448

Those two key exchanges have the same structure:

- They both use a prime field GF(<var>p</var>),
  whose characteristic is close to a power of two.
- The order of their curve is a big prime number &#x2113;,
  multiplied by a small cofactor <var>h</var>
  (<var>h</var>&nbsp;=&nbsp;8 for Curve25519,
  and <var>h</var>&nbsp;=&nbsp;4 for Curve448).
- They both use a base point <var>G</var> of prime order &#x2113;.
- They both "clamp" the scalar in the same way.
- They both use an x-only Montgomery ladder,
  which ignores the sign of the point.
  That is, <var>P</var>&nbsp;=&nbsp;(<var>u</var>,&nbsp;<var>v</var>)
  and
  &minus;<var>P</var>&nbsp;=&nbsp;(<var>u</var>,&nbsp;&minus;<var>v</var>)
  are considered the same point.
  In practice, this means we can ignore <var>v</var> altogether.

The key exchange itself proceeds as follows:

- Alice generates a key pair (<var>a</var>,&nbsp;<var>A</var>),
  and sends <var>A</var> to Bob.
- Bob generates a key pair (<var>b</var>,&nbsp;<var>B</var>),
  and sends <var>B</var> to Alice.
- Alice and Bob compute the shared secret <var>S</var>.

The private keys <var>a</var> and <var>b</var> are random numbers.
The rest have the following values (the dot denotes scalar
multiplication):

- <var>A</var>&nbsp;=&nbsp;`clamp`(<var>a</var>)&nbsp;.&nbsp;<var>G</var>
- <var>B</var>&nbsp;=&nbsp;`clamp`(<var>b</var>)&nbsp;.&nbsp;<var>G</var>
- <var>S</var>&nbsp;=&nbsp;`clamp`(<var>a</var>)&nbsp;.&nbsp;<var>B</var>&nbsp;=&nbsp;`clamp`(<var>b</var>)&nbsp;.&nbsp;<var>A</var>

The `clamp` operation is a hack designed to avoid leaking information
about scalars.
Any point <var>A</var> on Curve25519 and Curve448 is
the sum of a prime order point <var>P</var> and a low order point
<var>L</var>;
clamping is designed to ignore <var>L</var>:

> `clamp`(<var>s</var>)&nbsp;.&nbsp;<var>A</var>&nbsp;=&nbsp;`clamp`(<var>s</var>)&nbsp;.&nbsp;<var>P</var>

In practice, `clamp` does two things:

- It makes sure the highest non-zero bit is always in the same position.
  This [mitigates some side channel attacks][clamp] that may occur with some
  faulty implentations.
- It clears the lowest bits (3 for Curve25519, 2 for Curve448),
  so `clamp`(<var>s</var>) is a multiple of the cofactor <var>h</var>.
  This is the part that ignores the low order component.

[clamp]: https://mailarchive.ietf.org/arch/msg/cfrg/pt2bt3fGQbNF8qdEcorp-rJSJrc/

Normal public keys (almost) cover the whole prime order subgroup.
To cover the whole curve,
we just need to add a random low order point to it.
That low-order component will be ignored in key exchanges,
yielding the same shared secrets as we would have had with the normal
public key.

<aside>
Actually,
normal public keys only cover _half_ of the prime order group
(this is another effect of clamping).
But it does so in such a manner that for almost any prime order point
<var>P</var>,
either <var>P</var> or &minus;<var>P</var> (and not both) will be
covered.
X25519 and X448 get away with this because their scalar multiplication
ignores the sign of <var>P</var>.
In practice, we can cover the whole prime order group by randomly
flipping the sign of the public key.
</aside>

There are two methods to add a random low order point:

1. Generate a normal public key,
   then add a random low order point,
   selected with the clamped bits of the secret key.
2. Use a generator that generates the whole curve
   (and not just the prime order subgroup),
   and tweak the scalar to counter the effects of clamping.

Done right,
the two methods yield the exact same results.

<aside>
Actually,
since key exchange clears the cofactor,
the two methods do not have to yield the exact same results to be
compatible.
The reason we strongly recommend not just compatible,
but _identical_ outputs,
is because it is much easier to test.
</aside>


### Method 1: add a random low order point

This method is conceptually simple,
and potentially the fastest.
On the other hand,
it requires generic point addition,
which is best done in Edwards space.
This means performing the scalar multiplication in Edwards space,
then converting the final results to Montgomery space so Elligator can
work.
Scalar multiplication in Edwards space requires quite a bit of code,
which may be a problem on constrained applications that don't already
use it for other purposes,
like signatures.

We start with the following:

- The random secret bit string <var>s</var>, freshly generated for a
  single key exchange
  (256 bits for Curve25519,
  448 bits for curve448).
- the cofactor <var>h</var> of the curve
  (8 for Curve25519,
  4 for Curve448).
- The generator <var>G</var> of the prime order group of the curve
  (the one used in Ed25519 or Ed448).
- The generator <var>H</var> of the _low_ order group of the curve.
  It must be of order <var>h</var>.
  Curve25519 has 4 suitable candidates.
  Curve448 has 2.
  We can pick any of those,
  but some choices are slightly easier to implement than others.

The Edwards point
<var>E</var>&nbsp;=&nbsp;(<var>x</var>,&nbsp;<var>y</var>) is generated
from <var>a</var> as follows:

- <var>E<sub>high</sub></var>&nbsp;=&nbsp;`clamp`(<var>s</var>)&nbsp;.&nbsp;<var>G</var>
- <var>E<sub>low</sub></var>&nbsp;=&nbsp;(<var>s</var>&nbsp;`mod`&nbsp;<var>h</var>)&nbsp;.&nbsp;<var>H</var>
- <var>E</var>&nbsp;=&nbsp;<var>E<sub>high</sub></var>&nbsp;+&nbsp;<var>E<sub>low</sub></var>

<aside>
<var>L</var> may be computed with constant time selection and a very
small precomputed table.
</aside>

Once <var>E</var>&nbsp;=&nbsp;(<var>x</var>,&nbsp;<var>y</var>) is
generated,
we convert it to the Montgomery point
<var>P</var>&nbsp;=&nbsp;(<var>u</var>,&nbsp;<var>v</var>):

- <var>u</var>&nbsp;=&nbsp;(1&nbsp;+&nbsp;<var>y</var>)&nbsp;/&nbsp;(1&nbsp;&minus;&nbsp;<var>y</var>)

<aside>
We don't need the <var>v</var> coordinate here.
It is ignored by the key exchange,
Elligator only needs its sign,
and we have to randomly flip that sign anyway to cover the whole curve.
(We do need <var>v</var> for blind signatures,
but those are an entirely separate problem.)
</aside>

Once we have <var>P</var>&nbsp;=&nbsp;(<var>u</var>,&nbsp;?)
we just need to check whether it can be mapped
(this only depends on <var>u</var>).
If it cannot,
we try again with a new random scalar <var>s</var>.
If it can,
we randomly decide whether <var>v</var> is a principal square root or
not,
and apply the reverse map.


### Method 2: use a generator of the whole curve

This method reuses the x-only Montgomery ladder we use for
regular key exchanges,
and allows very compact code.
On the other hand,
it is about twice as slow as method&nbsp;1.

We start with the following:

- The random secret bit string <var>s</var>, freshly generated for a
  single key exchange
  (same as method&nbsp;1).
- the cofactor <var>h</var> of the curve
  (8 for Curve25519,
  4 for Curve448).
- The generator <var>G</var> of the prime order group of the curve.
  We use the same as method&nbsp;1.
- The generator <var>H</var> of the _low_ order group of the curve.
  We use the same as method&nbsp;1.

We can then pre-compute the special base point <var>K</var>:

- Find <var>m</var> such that
  <var>m</var>&nbsp;&#x2113;&nbsp;&equiv;&nbsp;1&nbsp;(`mod`&nbsp;<var>h</var>)  
  (<var>m</var>&nbsp;=&nbsp;5 for X25519,
  <var>m</var>&nbsp;=&nbsp;3 for X448)
- <var>K</var>&nbsp;=&nbsp;<var>G</var>&nbsp;+&nbsp;(<var>m</var>&nbsp;.&nbsp;<var>H</var>)

<aside>
We can compute this in Edwards space,
then convert the result to a Montgomery point.
</aside>

With <var>K</var> hard coded,
we can compute the rest entirely in Montgomery space,
with a single scalar multiplication:

- <var>s<sub>clamp</sub></var>&nbsp;=&nbsp;`clamp`(<var>s</var>)
- <var>s<sub>low</sub></var>&nbsp;=&nbsp;(<var>s</var>&nbsp;`mod`&nbsp;<var>h</var>)&nbsp;&#x2113;
- <var>P</var>&nbsp;=&nbsp;(<var>s<sub>clamp</sub></var>&nbsp;+&nbsp;<var>s<sub>low</sub></var>)&nbsp;.&nbsp;<var>K</var>

This gives us the exact same point <var>P</var> as method&nbsp;1.


Table of additional curve parameters
------------------------------------

The above procedure requires additional information about the curve
than is usually provided.
For the two most common curves Elligator can be applied to,
the required parameters are provided here.

For **curve25519** (Montgomery form):

<table>
<thead><tr><td>Variable</td><td>Type</td><td>Value</td></tr></thead>
<tbody>
<tr><td><var>G</var></td><td>Point (encoded x-coordinate)</td><td><code>34 fc 6c b7 c8 de 58 97 77 70 d9 52 16 cc dc 6c 85 90 be cd 91 9c 07 59 94 14 56 3b 4b a4 47 0f</code></td></tr>
<tr><td><var>n</var></td><td>integer</td><td>578960446&#8203;186580977&#8203;117854925&#8203;043439539&#8203;268569308&#8203;750392608&#8203;480156075&#8203;062836340&#8203;07912</td></tr>
<tr><td><var>n</var></td><td>integer (little-endian byte order)</td><td><code>68 9f ae e7 d2 18 93 c0 b2 e6 bc 17 f5 ce f7 a6 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80</code></td></tr>
</tbody>
</table>

For **edwards25519** (twisted Edwards form):

<table>
<thead><tr><td>Variable</td><td>Type</td><td>Value</td></tr></thead>
<tbody>
<tr><td><var>C</var></td><td>Point (integer coordinates)</td><td>(143993178&#8203;682001182&#8203;603479343&#8203;205272325&#8203;806188239&#8203;711943452&#8203;612142175&#8203;754167887&#8203;99818, 270738550&#8203;114484064&#8203;931822528&#8203;722565878&#8203;893680426&#8203;757531351&#8203;946374360&#8203;975030340&#8203;2022)</td></tr>
<tr><td><var>C</var></td><td>Point (compressed)</td><td><code>4a d1 45 c5 46 46 a1 de 38 e2 e5 13 70 3c 19 5c bb 4a de 38 32 99 33 e9 28 4a 39 06 a0 b9 d5 1f</code></td></tr>
<tr><td><var>n</var></td><td>integer</td><td>578960446&#8203;186580977&#8203;117854925&#8203;043439539&#8203;268569308&#8203;750392608&#8203;480156075&#8203;062836340&#8203;07912</td></tr>
<tr><td><var>n</var></td><td>integer (little-endian byte order)</td><td><code>68 9f ae e7 d2 18 93 c0 b2 e6 bc 17 f5 ce f7 a6 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80</code></td></tr>
</tbody>
</table>

For **curve448** (Montgomery form):

<table>
<thead><tr><td>Variable</td><td>Type</td><td>Value</td></tr></thead>
<tbody>
<tr><td><var>G</var></td><td>Point (encoded x-coordinate)</td><td><code>78 91 bd 50 c5 b8 16 f8 34 85 d0 81 e9 19 a8 d7 00 25 d3 51 e5 7a 9d f3 c4 9c df ae 7f 27 6f ed 3b a8 42 b7 fe 73 a8 ff 5b f3 a1 55 c2 c5 17 ba fd a4 79 69 c3 06 4a</code></td></tr>
<tr><td><var>n</var></td><td>integer</td><td>726838724&#8203;295606890&#8203;549323807&#8203;888004534&#8203;353641360&#8203;687318060&#8203;281490199&#8203;180584015&#8203;846158342&#8203;864783021&#8203;166769503&#8203;853241174&#8203;836366649&#8203;219095023&#8203;438599116</td></tr>
<tr><td><var>n</var></td><td>integer (little-endian byte order)</td><td><code>cc 13 61 ad 4a 0a e3 8d 54 3d 16 37 ca 09 b3 85 40 da 58 bb 26 6d 3b 11 a7 8f 28 f3 fd ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff</code></td></tr>
</tbody>
</table>

For **edwards448** (twisted Edwards form):

<table>
<thead><tr><td>Variable</td><td>Type</td><td>Value</td></tr></thead>
<tbody>
<tr><td><var>C</var></td><td>Point (integer coordinates)</td><td>(, ) !! TODO apparently this can't *just* be (1, 0)? Monocypher property-based checks fail if I replace `lop_x`, `lop_y` with (1, 0), so this probably has some subtle relationship with curve448 G</td></tr>
<tr><td><var>C</var></td><td>Point (compressed)</td><td>``</td></tr>
<tr><td><var>n</var></td><td>integer</td><td>726838724&#8203;295606890&#8203;549323807&#8203;888004534&#8203;353641360&#8203;687318060&#8203;281490199&#8203;180584015&#8203;846158342&#8203;864783021&#8203;166769503&#8203;853241174&#8203;836366649&#8203;219095023&#8203;438599116</td></tr>
<tr><td><var>n</var></td><td>integer (little-endian byte order)</td><td><code>cc 13 61 ad 4a 0a e3 8d 54 3d 16 37 ca 09 b3 85 40 da 58 bb 26 6d 3b 11 a7 8f 28 f3 fd ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff</code></td></tr>
</tbody>
</table>

**The points <var>G</var> and <var>C</var> are not nothing-up-my-sleeve
points.** Unlike the base point, these were chosen basically
arbitrarily.
The curve25519/edwards25519 ones match Monocypher.
The curve448/edwards448 were generated by whatever Sage felt like today
for the Weierstraß representation of curve448.


Bridging the Montgomery gap: Mappings for twisted Edwards curves
----------------------------------------------------------------

Elligator operates over a curve of the form <var>v</var><sup>2</sup>&nbsp;=&nbsp;<var>u</var><sup>3</sup>&nbsp;+&nbsp;<var>A</var><var>u</var><sup>2</sup>&nbsp;+&nbsp;<var>B</var><var>u</var>,
for which <var>A</var><var>B</var>(<var>A</var><sup>2</sup>&nbsp;&minus;&nbsp;4<var>B</var>)&nbsp;&ne;&nbsp;0.
However, you may wish to hide twisted Edwards curves instead;
for example because you need both signing/signature verification and
key exchange,
but are limited by code size rather than performance,
or your protocol involves presenting a signed and encrypted blob of
data before any actual Diffie&ndash;Hellman operation
for whatever reason, where the signature must also be hidden.
The solution is to apply steps before the inverse map and after the map.

For all of the following, **it is assumed that the points on the
twisted Edwards curve are in affine coordinates (<var>x</var>,&nbsp;<var>y</var>)**.
If your internal representation uses extended
(<var>X</var>&nbsp;:&nbsp;<var>Y</var>&nbsp;:&nbsp;<var>Z</var>&nbsp;:&nbsp;<var>T</var>) coordinates,
they must first be converted to affine coordinates:

1. <var>z</var>&nbsp;=&nbsp;<var>Z</var><sup>&minus;1</sup>,
1. <var>x</var>&nbsp;=&nbsp;<var>X</var>&middot;<var>Z</var>,
1. <var>y</var>&nbsp;=&nbsp;<var>Y</var>&middot;<var>Z</var>,
1. return the affine coordinates (<var>x</var>,&nbsp;<var>y</var>).

<!-- https://tools.ietf.org/html/draft-struik-lwip-curve-representations-00#appendix-C -->

To use the **inverse map**, first convert the twisted Edwards point
<var>P<sub>TEd</sub></var>(<var>x</var>,&nbsp;<var>y</var>)
to the equivalent point
<var>P<sub>Mont</sub></var>(<var>u</var>,&nbsp;<var>v</var>)
on the birationally equivalent Montgomery curve
This can be achieved as follows:

1. If <var>P<sub>TEd</sub></var>&nbsp;=&nbsp;(0,&nbsp;1), then
   signal an error.
   It corresponds to the point at infinity on the Montgomery curve,
   which cannot be encoded with Elligator.
1. If <var>P<sub>TEd</sub></var>&nbsp;=&nbsp;(0,&nbsp;&minus;1), then
   return <var>P<sub>Mont</sub></var>&nbsp;=&nbsp;(0,&nbsp;0).
1. <var>u</var>&nbsp;=&nbsp;(1&nbsp;+&nbsp;<var>y</var>)&middot;(1&nbsp;&minus;&nbsp;<var>y</var>)<sup>&minus;1</sup>,
1. <var>v</var>&nbsp;=&nbsp;(1&nbsp;+&nbsp;<var>y</var>)&middot;((1&nbsp;&minus;&nbsp;<var>y</var>)<var>x</var>)<sup>&minus;1</sup>,
1. Construct and return
   <var>P<sub>Mont</sub></var>(<var>u</var>,&nbsp;<var>v</var>).

After that, the inverse map can be used as above.

To use the **direct map**, after obtaining the point
<var>P<sub>Mont</sub></var>(<var>u</var>,&nbsp;<var>v</var>)
on the Montgomery curve, map it to twisted Edwards space.
This can be achieved as follows:

1. If <var>P<sub>Mont</sub></var> is the point at infinity,
   signal an error or abort execution entirely.
   This should *not* be a possible input to the conversion function
   after the direct map.
   If this function is used for other contexts, too,
   then you may return <var>P<sub>TEd</sub></var>&nbsp;=&nbsp;(0,&nbsp;&minus;1).
2. If <var>P<sub>Mont</sub></var>&nbsp;=&nbsp;(0,&nbsp;0), then
   return <var>P<sub>TEd</sub></var>&nbsp;=&nbsp;(0,&nbsp;&minus;1).
3. <var>x</var>&nbsp;=&nbsp;<var>u</var>&middot;<var>v</var><sup>&minus;1</sup>,
4. <var>y</var>&nbsp;=&nbsp;(<var>u</var>&nbsp;&minus;&nbsp;1)&middot;(<var>u</var>&nbsp;+&nbsp;1)<sup>&minus;1</sup>,
5. Construct and return
   <var>P<sub>TEd</sub></var>(<var>x</var>,&nbsp;<var>y</var>).

<aside>
You may be wondering why Elligator&nbsp;1 is ignored,
which itself operates over twisted Edwards curves.
The reason for that is that it is generally accepted
that Elligator&nbsp;2 is the superior solution to the problem.
This is because *every* curve that has a point of order&nbsp;2
supports Elligator&nbsp;2.
On the other hand, Elligator&nbsp;1 requires a (twisted) Edwards
curve in a field GF(<var>p</var>) where
<var>p</var>&nbsp;=&nbsp;3&nbsp;(mod&nbsp;4).
However, in such fields, the curve parameter &minus;1 is *non-square*.
This makes it unsuitable for twisted Edwards curves whose curve
parameter <var>a</var>&nbsp;=&nbsp;&minus;1 because <var>a</var>
because addition is no longer well-defined for all inputs
with <var>a</var> being non-square.
Any good twisted Edwards curve needs
<var>a</var>&nbsp;=&nbsp;&minus;1 because the fastest known
point addition formulae require it.
Therefore, nobody wants to use curves suitable for Elligator&nbsp;1
because they incur a performance penalty.
Accordingly, the Curve1174 presented in the Elligator paper has found
no adoption.
</aside>


Ristretto and Decaf
-------------------

!! TODO (inverse map can be taken from https://tools.ietf.org/html/draft-irtf-cfrg-ristretto255-decaf448-00#section-4.3.4,
but it's a "one-way" map... I'm not sure if this can be made to work
bi-directionally.)
